## TYPES OF COMMITS
################################
[<runCode>] Milestone Completed Commit		Just at the end of a major Q/A cycle before initiating work on the next milestone
[<runCode>] Q/A Start Commit				Just before starting a Q/A run
[<runCode>] End of Day Commit				Periodic routine End of Day commit


# SCHEDULE
################################
................................
[ ]		LATER
		........................
[ ]	File-Backup
		[ ]	Implement sidecart-metadata files for backed-up datastreams
................................
[ ]		Q/A
		........................
[ ]		.
................................
................................
................................
[ ]		NEXT MILESTONE: 0004
		........................
[ ]		.
................................
[ ]		Q/A
		........................
[ ]		.
................................
[ ]		NEXT MILESTONE: 0003
		........................
[ ]		.
................................
[ ]		Q/A
		........................
[ ]		.
................................
[.]		NEXT MILESTONE: 0002
		........................
[X]		Controllers: Restrict methods to logged_in only
[X]		Implement methodology to restrict inherited model functionality conditionally (e.g. get/set data only if... (user is logged in, e.g.))
[X]		figure out how to switch between sessions (relative "current session" vs. absolute sessions...)
		> possibly irrelevant as sessions will operate in their local scope. Methods requiring a global scope across all sessions can refer to the sessions parent and iterate through active sessions.
[X]		models_master.BSModel._get_model_superclass: *iterate* through superclasses, not only the first...
[X]		SessionsModel:
		[X]	figure out how to identify a session
			> address when actually needed (refer to "switch between sessions" task)
		[X]	remove_session()
[.]	Do I need objects to represent sources, targets, filters, etc. or do lists suffice?
[X]		SourcesModel:
		[X]	add_source(source)
		[X]	remove_source(source)
		[X]	sources property (returns list of sources, needs to return full set inc. id as it will be used as identifier to address a source (removing etc.))
[.]		TargetsModel:
		[.]	add_target(target, password)
		[ ]	remove_target(target)
		[ ]	targets property (return list of targets)
[ ]		FiltersModel
		[ ]	add_filter(filter)
		[ ]	remove_filter(filter)
		[ ]	filters property (return list of filters)
[X]		SetsModel
		[X]	add_set(sources, targets, filters)
		[X]	remove_set(set)
		[X]	sets property (return list of sets)
			> Not needed for now. Will probably implement later (in UI) through self._get("all where user_id = user_id...") call
[.]		Start with backup-factory
		[.]	Think about and lock down approach/philosophy of how to look at file data/individual entities, tracking, ...
		[X]	Implement conditional matrixes to handle different cases
		[X]	Profile 1 vs. 2-threaded hash-calculation (1 thread read/buffer data, 2nd thread calculates hash)
			> 2 threaded always faster. low sleeper-times speed up but are still necessary to keep cpu load under control (free while loops maximize cpu load unnecessarily)
		[X] Implement 2-threaded hash-calculation into backup-routines
		[X]	Implement organizational plan for file-data
		[X]	Implement compression
		[X]	Implement sidecart-metadata files for backed-up datastreams
			> Not for now~
		[X]	Integrate code properly into bs structure (from current tmp working files)
		[X]	benchmark/optimize for speed
		[ ]	BackupRestore: Fully implement into DB-environment; only pass in set, password, entity_id, restore_location (auto-picks target from available)
		[ ]	Implement mechanism to check password on extract before starting (on one specifically selected target...)
		[ ]	Store *one* password hash with a whole *backup-SET*
		[ ]	Pass password into backup-method and check for validity before starting backup-process ()
			[ ]	Think: How to handle password management when multiple targets with different passwords are used in a backup set/process~
[ ]	Backup obj/Database
		[ ]	Implement mechanism to mark an entity as absent in a snapshot
		[ ]	Table `path` still needed? Unique per entity anyway, so won't change between snapshots
................................
[ ]		Q/A
		........................
[ ]		clean-up old code
[ ]		check module-structure
[ ]		maintain integrity:
		[ ]	document code
		[ ]	validate user-input
		[ ]	write test/test
		[ ]	manage conditional exception-handling
		[ ]	implement correct return data for *everything*
		[ ]	address warnings/errors
		[ ] standardize logging-messages
		[ ]	make sure all logging messages are very *specific* in regards to
				- origin of message
[ ]		clean-up current code:
		[ ]	update representations
		[ ] any code-warnings/errors
................................
[X]		NEXT MILESTONE: 0001
		........................
[X]		automatically create default user
[X]		user can log in, out
[X]		sources, targets, sets, filters can be loaded/saved/removed
................................
[X]		Q/A
		........................
[X]		clean-up old code
[X]		check module-structure
[X]		maintain integrity:
		[X]	document code
		[X]	validate user-input
		[X]	write test/test
		[X]	manage conditional exception-handling
		[X]	implement correct return data for *everything*
		[X]	address warnings/errors
		[X] standardize logging-messages
		[X]	make sure all logging messages are very *specific* in regards to
				- origin of message
[X]		clean-up current code:
		[X]	update representations
		[X] any code-warnings/errors
................................
